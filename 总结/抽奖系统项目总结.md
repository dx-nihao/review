# 抽奖系统项目总结

数据库相关设计

<img src="C:\Users\hasee\AppData\Roaming\Typora\typora-user-images\image-20220625203933812.png" alt="image-20220625203933812" style="zoom: 50%;" />



# 一.项目相关的Spring使使用

## 1.SpringMVC的使用

### （1）概念

是一种架构模式，将软件系统分为model，controller，view。

模型：将请求数据转化为model，和数据库中数据的存取相关。

控制器：用于web的请求和响应处理

视图：返回一个HTTP响应的视图（html，js数据，文件）

过程：用户发送HTTP请求后，首先由Controller层接收请求，并将请求数据转化为model，业务操作后，将数据包装成view视图返回给用户。

### （2）数据接收的类型和方式

@RequestParam/@RequestPart(文件相关)默认必传

方法参数为基本数据类型（包装类）和自定义类型时，只能接收quertyString,form-data,表单数据格式。

前端发送json格式数据后端加@RequestBody。

文件上传使用MultipartFile类型的对象。

### （3）Spring中的常见注解和用途

#### 1.类注解（该类会被注册到容器中）

@Controller(请求和响应) 			@Service（业务逻辑处理） 	@Reposistory（数据库操作）

@Component（一般组件）		@Configuration（系统启动前的一些配置）



#### 2.MVC中常用注解

@RequestMapping:请求映射方法的注解			@PathVariable:获取URL中的参数

（获取Cookie和Session：方法参数中加HTTPServletRequest类型的参数/@CookieValue,@SessionAttribute）

@ResponseBody（不加返回字符串会报错，可以返回一个html文件）:加上就给前端返回json数据而不是view，会将返回对象自动转为json字符串（返回字符转换为text/html）

@RestController=@Controller+@ResponseBody

### （4）SpringMVC的执行流程

![image-20220621154625062](C:\Users\hasee\AppData\Roaming\Typora\typora-user-images\image-20220621154625062.png)



### (5)SpringMVC中拦截器的作用

是用于对处理器进行预处理和后处理，用户可以自定义一些拦截器来实现一些特定的功能；只能拦截访问控制器的方法，拦截器只能在SpringMVC框架中才能使用。

## 2.Mybatis的使用

### （1）概念

是一个ORM框架（对象关系映射：数据与对象建立关系，自动地进行数据与对象之间地转换）。

表转为类，表中字段转为对象属性，行数据转化为对象。

### （2）数据交互流程

数据发送到Controller层，再到Service层，之后再Mapper（持久层）调用数据库（这里包含InterFace和.xml实现接口），生成地sql调用jdbc来操作数据库。

### （3）JDBC的操作流程

1.创建数据库连接对象

DriverManager创建连接或DataSource创建数据库连接池

2.创建操作命令对象

Statement，预编译的PreparedStatement，CallableStatement

3.执行sql

先替换占位符，再执行sql（如果为查询还需要处理结果集）

4.释放资源

### （4）Mybatis为什么可以使用接口就可以执行方法

因为Mybaits通过动态代理生成了接口的实现类（MapperPorxy）。

通过getMapper方法获取一个JDK动态代理对象，其中动态代理类会继承MapperProxy（代理）类，实现被代理的接口并且里面持有一个MapperProxy类型的触发管理类；

拿到代理类后，调用方法时，调用功能MapperProxy的invok；

springboot就会读取xml解析为配置，之后使用@Autowired放入的是代理对象

### （4）一对多及一对一的关系映射

使用ResultMap将数据库中的数据转化为Java对象

1.一对一：在resultMap中配置一个<association>,对象属性为一个对象

2.一对多：在resultMap中配置一个<collection>，对象属性为list

### （5）Mybatis中，为什么可以将Mapper接口直接注入使用（原理是JDK的动态代理生成了接口的实现类）

MapperScannerConfigurer自动扫描将Mapper接口生成代理注入到Spring中。

原理是：Mybatis在与Spring集成的时候可以配置MapperFactoryBean来生成Mapper接口的代理。

Mybatis创建了MapperFactoryBean的代理类实现了.mapper接口并且注入到了SpringBean容器中

## 3.为什么使用SpringBoot

快速集成框架，内置运行容器（Tomcat），快速部署项目，多的监控指标可以了解项目的运行情况，不使用xml，使用注解和配置的方式进行开发。

特点：约定大于配置



## 4.SpringAOP的使用

### （1）概念

AOP：面向切面编程，作用是一处横切代码（切面代码）可以实现所有业务统一的功能。

### （2）使用场景

统一日志记录，统一方法执行时间统计，统一的返回格式，统一的异常处理，事务的开启和提交。

### （3）AOP的组成

包括切面，切点，连接点，通知。

切面：包含切点，通知，横切代码（整个过程）

连接点：业务方法（加入横切统一逻辑的方法）（横切后要执行的方法）（所有业务方法调用）

切点：配置一组规则，用于匹配需要横切的业务方法（连接点）（拦截后执行的方法）

通知：定义业务方法在什么时候进行执行横切的代码。（拦截后执行方法的方法体）

通知：前置通知（目标方法调用前），后置通知（返回后或异常后），返回后通知（方法返回后），异常后通知（抛异常后），环绕通知(通知前和调用后)

### （4）AOP的具体实现

![image-20220620211817403](C:\Users\hasee\AppData\Roaming\Typora\typora-user-images\image-20220620211817403.png)

### （5）SpringAOP的原理

SpringAOP是基于方法进行拦截，实现方式有JDK（接口方式），CGLIB（继承方式）。

SpringAOP实现了动态代理这种设计模式。

通过动态代理（运行期间织入增强的代码），对目标对象（被代理类）加入一定的代码形成代理类。

JDK实现过程：被代理类实现一个接口，通过JDK提供的InvocationHandler和Proxy来生成代理类。

CGLIB实现过程：使用字节码框架（增/删/改字节码）来织入代码：织入就是生成代理类的逻辑，生成一个代理类（继承被代理类），重写方法（织入增强的字节码）



## 6.项目中敏感资源访问使用的拦截器（统一登录校验）

### （1）为什么使用拦截器

项目中需要统一处理的有：http请求信息，敏感资源访问时身份的验证。

由于无法获取到http请求对象和session对象，所以没有使用AOP来进行处理。

这里是通过Spring的拦截器来进行处理。



### （2）Spring中拦截器的使用及方式

HandlerInterceptor：请求映射方法的拦截，可以获取到HTTP请求和响应对象

实现方式：自定义拦截器类**实现一个HandlerInterceptor接口**，**重写preHandle方法**，然后再将拦截器配置到SpringMVC框架中，配置的规则是，在带有@Confiuration注解的自定义配置类中，**实现一个WebMvcConfigurer接口**，然后**在重写addInterceptors方法中添加该拦截器**，并且配置拦截规则。

配置拦截规则的时候使用到了统一路径前缀，目的是为了区分前后端代码，后端之后也方便进行登录拦截。

### （3）配置好拦截器的执行顺序

收到请求后，如果不满足拦截规则，就执行请求映射方法；满足拦截规则，先执行拦截器中的preHandle方法，如果登录过了，就执行请求映射方法，如果没有登录，就返回一个401，禁止接下来的访问。



## 7.项目中统一异常处理方式

使用方式：

<img src="C:\Users\hasee\AppData\Roaming\Typora\typora-user-images\image-20220622212909647.png" alt="image-20220622212909647" style="zoom: 67%;" />



## 8.项目中统一数据返回格式

### （1）为什么使用数据统一处理

统一规范，前端方便解析数据，降低前后端开发人员的沟通成本，有利于数据的统一维护和修改。



### （2）具体的使用方式

<img src="C:\Users\hasee\AppData\Roaming\Typora\typora-user-images\image-20220622214425273.png" alt="image-20220622214425273" style="zoom: 50%;" />



## 9.Spring中事务的使用

### （1）事务的4大特性

原子性（全部成功或失败）	持久性（持久到硬盘中）	一致性（业务层面满足数据的一致性）	隔离性（并发时，是否对其他事务隔离可见）

### （2）为什么项目中开启事务

首先，一般开启事务是在service层，由于自己代码中存在多个sql，且之间具有一定的逻辑，由于执行多行sql不具有原子性，所以使用到了事务。

自己在注册页面开启了事务，因为setting和user表之间是1对1的关系，在向两张表插入时，涉及到了原子性问题，需要保持一致，所以在这里开启了事务

### （3）Spring中事务的2种处理方式

#### 1.编程式事务（自己开启事务，提交或回滚）

通过三个类来手动开启：事务管理器，事务状态，事务定义

#### 2.声明式事务（通过注解自动开启事务）

使用@Transactional（isolation="设置隔离级别的值"）

### （5）数据库并发导致的一致性问题

1.丢失更新：（并发执行时间不同）一个事务修改的内容把另外一个事务修改的内容给覆盖了。

2.脏读：一个事务读取到了另一个事务未提交的数据。	

3.不可重复读：一个事务多次读取到的数据不一致。

4.幻读：一个事务读取时，有其他事务进行插入，导致行集不同。

### （6）事务的隔离级别以及在spring中设置的隔离级别

读未提交，读已提交（解决了脏读，Orcal默认级别），可重复读（解决了不可重复读，MySQL默认级别），可串行化（所有都解决了，效率最低）

### （7）Spring事务的传播机制

#### 1.事务传播机制的条件

当一个方法执行多个sql时（有隔离级别），这时候存在其他方法调用当前方法时，就可能会使用到事务的传播机制。

#### 2.事务传播机制的使用方式和说明

总共有7种

通过在@Transactional(Prapagation=...)进行设置。

常见的有：

Prapagation.REQUIRED：默认的传播机制，如果上一层存在，就使用，否则就创建一个新的

Prapagation.NESTED:如果上一层存在，就进行嵌套，否则就等价于Required



# 二.Spring面试题总结

## 1.数据库相关框架

ORM：对象关系映射，是将数据库表和数据映射为Java对象。

MyBatis    																Hibernate

半自动化，数据库模型依赖稍低							自动化

不可以跨数据库，易维护 									 可以

## 2.Spring容器

### （1）用途

管理bean对象和对象之间的依赖关系

### （2）Java中的两个spring容器

BeanFactory：最底层的容器，只有Bean的实例化和依赖注入，是懒加载方式，调用getBean进行实例化 

ApplicationContext：BeanFactory的子接口，是预加载；除了基本功能，还有bean对象的生命周期的管理，国际化功能，AOP，事件机制，复杂的上下文

## 3.IoC和DI（通过依赖反射和字节码框架来实现）

(1)IoC

控制反转

之前由程序管理对象的依赖关系，现在由Ioc容器来管理bean，控制权发生了反转

（2）DI(IoC的实现方式之一)

容器组织对象间的依赖关系

依赖注入的实现方式：属性注入和构造注入



## 4.单例bean的线程安全问题

有状态的单例bean存在线程安全问题（修改bean的成员变量）

解决方式：使用ThreadLocal

## 5.Bean的作用域

单例的（一份bean实例），原型的（每次请求创建新的bean实例），request（范围内，产生新的），session（范围内，产生新的），application（范围内，产生新的），websocket（范围内，产生新的）

## 6.FactoryBean和BeanFactory

(1)FactoryBean

生产bean的工厂类，通过实现该接口，重写getObject()方法，作为工厂方法，之后根据工厂方法创建bean对象并注册到容器中

(2)BeanFactory

spring容器的顶级接口，bean对象通过该容器来进行管理

## 7.Bean生命周期

实例化；依赖注入；初始化：实现各种aware通知接口的方法，执行预初始化方法，，初始化方法，后初始化方法；使用bean，销毁bean

## 8.循环依赖

### （1）spring可以解决的

spring支持的循环依赖：单例模式下的属性注入

### （2）解决过程（三级缓存）

一级缓存：存放完整的bean对象	二级缓存：存放提前曝光的bean对象		三级缓存：存放bean的工厂对象

具体流程（AB循环依赖时）

首先初始化A时，将new 的A放到三级缓存中，然后注入A的属性B,执行B的初始化，然后将B放到三级缓存中，注入B的属性A，发现循环依赖，这时候从三级缓存中获取到A，然后通过工厂方法生成A，将A放到二级缓存中，并将三级缓存中的A进行删除，然后执行B后续的生命周期流程，生成了一个完整的B后，将B放到一级缓存中，A方法调用链返回后，已经注入了一个完整的B，执行后续流程，然后A也注册成功，放到一级缓存中。

### （3）可以使用二级缓存解决循环依赖吗

可以，但是有一些设计和场景上的限制。

## 5.拦截器和过滤器的比较

### （1）过滤器

依赖于servlet容器，实现上是基于函数的回调，几乎可以对所有请求进行过滤；缺点：一个过滤器只能在容器初始化时调用一次；主要用来进行一些过滤操作，如过滤低俗文字，危险操作等。

### （2）拦截器

依赖于web框架，基于java反射机制进行实现，AOP的一种运用，动态代理是拦截器的简单实现，一个拦截器可以在一个controller声明周期中进行多次调用，但是只能对controller请求进行拦截，对于其他静态资源的请求没办法拦截。



## 6.Spring中单例是如何实现的

通过ConcurrentHashMap采用单例注册表实现

