# 面经总结



## 1.面向对象

在计算机中用类似的实体描述现实中的实体，如一辆车就是一个对象，它有属性如颜色，牌子；它还能开动，要维修，就是它的行为。

面向对象的特性：封装，继承，多态。

## 2.linux下查看ip地址

ifconfig-a

## 3.性能测试的方法以及需要测试的内容

压力测试：采用后端性能测试的方法，不断向系统施加压力，直到达到临界点；有时还需要继续施压，直到崩溃，崩溃后逐渐减小压力，然后查看瘫痪的系统可以自愈。

并发测试：同一时间，同时调用后端服务，观察并发情况下的行为，如发生死锁，资源竞争等问题。

可靠性测试：系统在常规压力下运行的稳定性，通过长时间的模拟真实系统的负载，查看系统潜在的内存泄露等问题。

代码级性能测试：在单元测试阶段对代码的时间性能和空间性能的测试和评估。

后端性能测试：模拟大量用户并发，获取系统的各项性能（并发数，响应时间，系统吞吐量，CPU占用率），并且检验各项指标是否满足需要的性能指标。

前端性能测试：浏览器端的页面渲染时间，资源加载时间，前端缓存使用情况，请求数量。

配置测试：观察不同配置条件下系统的性能情况，像数据库配置，操作系统的配置等。



## 4.进程和线程

### （1）进程

进程：正在执行程序的实例，是一个程序的执行流程，进程中包含程序，数据，进程控制块（PCB）。

进程的创建：系统初始化（启动操作系统时，通常会创建很多进程），正在运行的进程执行了创建进程的系统调用，用户请求创建一个新的进程（像双击一个图标时），批处理作业的初始化。

进程的状态：就绪，运行，阻塞

进程和程序的区别：进程是动态的，程序是静态的，程序是进程的基础，程序每次运行都会产生不同的进程。

进程挂起：阻塞挂起（将内存中的进程移到外存中），就绪挂起（进程在外存中，进入内存就可运行）。挂起后进程就处于外存中。

进程调度：多个进程抢占一个cpu时会出现进程调度，有抢占式和非抢占式调度。

调度算法：先来先服务，最近最久未使用，时间片轮转等

什么时候会进行调度：创建新线程后，一个进程退出时，一个进程阻塞时，

### （2）线程



### （3）进程和线程常见的IPC方式（通讯方式）

管道，信号量，套接字socket，消息队列，共享内存

### （4）进程和线程的区别

进程是系统分配资源的最小单位，线程是cpu调度的最小单位，一个进程中最少包含一个线程。各个进程之间相互独立，线程之间共享内存。进程对系统的开销比较大，线程比较轻量。一个线程崩溃，会导致所属进程的所有线程崩溃。线程在进行并发读写同一块数据时，有线程安全问题。

（5）一个进程中的某个线程非法访问内存后，进程出现什么

因为一个进程之间的线程是共享内存，所以在非法访问内存后，之后内存操作可能会出现不确定性，所以一般进程会直接崩溃。

进程状态转换图

<img src="C:\Users\hasee\AppData\Roaming\Typora\typora-user-images\image-20220628213248951.png" alt="image-20220628213248951" style="zoom: 50%;" />

## 5.主键和索引的区别

主键包含单一主键和联合主键

索引包含单一索引和联合索引

主键一定是索引，索引不一定是主键，一张表只能有一个主键，可以有多个索引，主键字段不能为空，索引字段可以为空。

## 6.session和cookie的区别

cookie是客户端的数据存储技术，session是服务端的存储技术

cookie解决不同请求的请求数据的共享问题，session的id是依赖于cookie来进行存储的。

cookie不安全，可能会存在cookie欺骗，cookie保存的数据有限制，session没有。

cookie可以设置过期时间，而session只能进行销毁，且关闭浏览器后session也会失效。



## 7.在地址栏输入www.baidu.com发生了什么

（1）首先会在主机上查找DNS的缓存，如果有，就将域名转化为IP地址，如果没有就给本地DNS发送查询请求，本地的DNS会向根域名服务器发送查询请求，根域名告知该域名的一级服务器，然后本地服务器给一级域名服务器发送请求，重复上述步骤，直到查询到该域名的IP地址。（DNS基于UDP）

（2）应用层

得到IP地址后，会将数据进行封装，其中包含HTTP请求报文，请求方法get，遵循的协议，然后应用层发起http请求（如果使用https还会对数据进行加密）

(3)传输层（包含源端口和目的端口）

通过TCP协议进行端到端的传输数据，中间会对数据分割成报文段对数据包进行编号管理，中间会通过3次握手建立连接。

（4）网络层（包含源IP和目的IP）

根据IP地址并使用ARP协议来获取mac物理地址，如果在同一局域网内，并且在ARP缓存表中没有找到mac，会以广播的形式进行喊话，如果某个端口发现是自己的IP，那么就会返回自己的mac地址。当不在同一局域网内，就会通过路由选路，一跳一跳的进行寻址。

（5）数据链路层（包含源mac和目的mac）

找到mac地址后，就将数据发送到数据链路层，数据链路层会对数据通过以太网帧进行封装，之后数据就进行发送，然后在物理层以bit流的形式进行发送，之后再对数据一层一层进行分用到应用层，应用层解析后，将响应页面返回到前端，然后前端对数据进行渲染到页面上。



## 8..服务器访问量非常大，它是怎么实现并发访问的

服务器集群，缓存技术，WEB脚本和静态资源的分离。



## 9.关于测试，一般的开发模型你了解的有哪些

瀑布模型：需求分析，计划，设计，编码，测试。阶段独立，测试后期介入。

螺旋模型：项目庞大，需求不明确。成本高，风险高。

增量，迭代模型：抗风险能力强

敏捷模型：重于个体与交互，重于客户协作，轻文档，轻流程，重目标，重产出

发布计划会议：产品经理整理需求形成userstory进行讲解，之后userstory形成sprintbacklog.

迭代计划会议：分析userstory并分解成一个个任务，分配给开发人员，制定开发计划

每日例会：昨天干了什么，遇到的问题，今天的任务，

产品演示会议：甲方，用户演示产品，把不足的形成userstory，下一次迭代改进

回顾计划会议：回顾整个迭代计划，找出不足，下一次迭代改进

测试模型：

V模型：用户需求，需求分析，概要设计，详细设计，编码，单元测试，集成测试，系统测试，验收测试

独立性强，测试介入晚。

W模型：独立性强，测试一开始介入。开始就由测试计划，之后直接进行测试



## 10.对称加密和非对称加密

对称加密：加密解密使用同一把密钥

非对称加密：加密解密使用密钥对，公钥和私钥，私钥只能由一方保管，不能泄露



## 11.TCP和UDP的区别

TCP:可靠传输，面向字节流，有发送缓冲区和接收缓冲区，有连接，只支持单播（点对点传输），大小不限。

UDP:不可靠，面向数据报，有接收缓冲区，无连接，（可以单，多，广播），大小受限。



## 12.什么是java虚拟机

启动一个java进程，就会创建并运行java虚拟机，之后加载字节码，运行时翻译成机器码让cpu进行执行。

jdk>jre>jvm



## 13.java的运行时数据区

线程私有

本地方法栈：本地方法

虚拟机栈（生命和线程相同）：局部变量表，操作栈，动态连接，方法返回地址；栈中存放的是方法的栈帧（方法调用完，该方法对应的栈帧也就被销毁了）

程序计数器：记录行号

线程共享

方法区（元数据区）：类信息（静态变量，常量），方法信息，运行时常量池

堆：存放对象，字符串常量池



## 14.内存溢出和内存泄漏

可能发生在堆方法区，栈中

概念：内存溢出是某个运行时数据区创建的数据导致空间不足，而创建的对象还应该存活。

内存泄漏是没有用的对象GC无法回收，最终导致的结果也是内存溢出

解决方案：内存泄漏：定时清理无用的数据，使用弱引用，软引用来保存数据，加大内存，定时重启程序。

栈溢出（发生在栈中）：栈帧调用太深导致（递归）。



## 15.什么时候会发生类加载

java  类名时，对静态方法，静态变量进行操作，new 对象时，反射创键类对象然后再反射生成实例对象时。



## 16.类加载的过程

加载：将字节码文件加载到方法区中，然后在堆中生成一个类对象

验证：验证class文件是否符合jvm规范

准备：对静态变量初始化，常量设置为真实值

解析：初始化常量的过程（对常量池中的符号引用替换成直接引用）

初始化：对静态变量，静态代码块进行初始化



## 17.类加载机制

双亲委派模型：从下到上进行查找，从上到下依次执行

从上到下依次是：启动类加载，扩展类加载，应用类加载，自定义类加载。

双亲委派模型的优缺点：确保安全，扩展性不足



## 18.JVM中的垃圾回收

### (1)java中判断对象是垃圾方式

可达性分析算法：从gcRoot开始沿着引用链向下搜索，如果无法到达的对象就是垃圾。



### （2）四种引用类型（了解）

强引用：new的对象

软引用：OOM发生时回收的对象

弱引用：下一次垃圾回收时，回收的对象

虚引用：垃圾回收发起一个通知



### （3）垃圾回收算法

标记清除：标记后进行清除；效率低，存在内存碎片

复制算法：将内存分为2块，每次将存活对象放到另一块空间中，然后再将之前使用的空间清除；效率高，不会出现内存碎片，内存利用率低

标记整理：将存活对象移动到连续的空间，然后再清理剩余的空间；不存在内存碎片

分代回收算法：将内存空间分为新生代（一个E区，两个S区，8:1:1），老年代。

每次只使用E区和一块S区来保存对象，gc时将存活的对象使用复制算法到另一块空闲的S区，如果空间不够，会使用老年代的空间，之后每经过一次GC，对象的年龄+1，大于15后对象就会进入老年代，之后老年代采用的是标记清除或标记整理算法来管理。

垃圾收集器：

用户体验优先：ParNew（新生代，复制算法），CMS（老年代，标记清除），G1（全堆收集器，划分多个区域，每个区域有E,S，老年代区域，整体为标记整理算法，局部为复制算法）

吞吐量优先：Parallel Old（老年代收集器，标记整理），Parallel Scavenge(新生代，复制算法)

CMS阶段：

初始标记（标记gcRoot），并发标记（引用链搜索），重新标记（修改并发标记发生变动的记录），并发清除（清除对象），

G1都分为4个阶段

初始标记，并发标记，最终标记，筛选回收



## 19.七层网络模型

物理层：传输0,1数据（集线器，网线）

数据链路层：识别数据帧，发送数据报到下一个网络硬件设备（ARP，以太网帧，交换机）

网络层：地址与路由选择(IP协议，路由器)

传输层：确保数据传输的可靠性（TCP,UDP协议，主机的操作系统）

会话层：建立会话管理

表示层：确定接收端展示的方式（提供数据格式的转换）

应用层：应用程序所在的分层（HTTP,DNS，SSH）  （访问网络服务的接口）



## 20.测试UDP和TCP是否正常的方式

（1）使用telnet命令查看TCP的端口是否正常

（2）linux下安装nc（yum install -y nc）,然后使用

nc -vz  ip+port 测试TCP

nc -vuz ip+port 测试UDP



## 21.解决hash冲突的方法

（1）开放地址法：冲突时，再寻找下一个空位置。

（2）再哈希：冲突时，使用第二/三个哈希函数计算地址，直到无冲突。

（3）链地址法：链表形式

（4）建立公共溢出区：将hash表分为基本表和溢出表，发生冲突的元素放到溢出表中



## 22.Mysql两种存储引擎

### （1）存储引擎

MyISAM

性能好，支持全文索引，但不支持事务和行级锁，崩溃后无法恢复，

为表级锁，不支持外键，

InnoDB（事务性数据库引擎）
支持事务和崩溃后的数据恢复，默认为行级锁，支持外键，支持MVCC；5.6后也支持全文索引

### （2）什么是当前读和快照读

当前读：读取的是目前数据库的最新版本，读取时保证其他事务不能修改当前记录，所以对读会进行加锁

快照读：不加锁的非阻塞读，前提是隔离级别不能为串行化（退化为当前读），快照读的实现基于MVCC。

### （3）MVCC

是一种多版本并发控制的一种方法，指的是维持一个数据的多个版本，使得读写操作没有冲突，在InnoDB中的实现主要是提高并发性能，在读写即使有冲突的情况下，也做到不加锁，非阻塞并发读。

主要解决读写问题，只读取事务开始时的最新快照，而不读取正在修改的数据；做到了读写时不加锁，提高了性能，也解决了脏读，幻读，不可重复读时事务带来的问题，但不能解决丢失更新。

实现原理：基于记录中的三个隐式字段，undo日志和read view来实现。

## 23.数据库连接池

减少创建的开销；每个用户打开和维护数据库连接浪费资源，在连接池中创建好连接后，放在池中，再次使用时不再进行创建新的连接，如果所有连接都使用了，就建立新的连接再放到池中，减少了用户等待建立与数据库连接的时间。

## 24.有关HashMap和CurrentHashMap

（1）HashMap

多线程时会发生什么问题：在扩容的时候会造成死锁，会形成一个环，get后会发生死循环；在jdk1.8后已经解决了该问题，但是会造成其他问题，如数据丢失。

如何使hashmap变得线程安全：

1.使用Collections下用synchronized包装的hashmap，其中put和get使用了synchronized

2.使用juc下的ConcurrentHashMap，使用了cas和使用synchronized对每一个hash桶加锁







