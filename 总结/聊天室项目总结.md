# 聊天室项目总结

数据库表的设计

<img src="C:\Users\hasee\AppData\Roaming\Typora\typora-user-images\image-20220721164904301.png" alt="image-20220721164904301" style="zoom: 67%;" />

## 1.Maven相关知识

Maven是一个项目管理工具，可以构建项目，可以解决导入依赖于Java类的jar包和对项目的编译（compile），可以对项目进行打包(package)，清除（clean）。



## 2.Tomcat相关知识

### （1）相关概念

tomcat是一个Http服务器，也是一个servlet容器。

### （2）浏览器发送请求数据后tomcat如何进行处理的

首先前端发送一个HTTP请求，其中包含一些数据，服务端收到这个HTTP请求后，交给Tomcat来进行处理，之后tomcat对请求进行解析，然后将url映射关系来将数据交给指定的servlet类中的指定方法doXXX。之后将响应数据构造好后返回给浏览器。

### （3）tomcat的启动

init()方法：初始化只进行一次。

service（）方法：收到请求后就会执行该方法，在该方法中有doXXX方法，在该过程中会触发多态机制。

destory():服务器运行结束后，进行资源的回收

### （4）部署项目及访问方式

可以将自己的项目部署到webapps的目录下，之后可以通过路径+应用上下文可以在浏览器中进行访问。





## 3.HTTP协议的相关知识

### （1）概念

基于TCP/IP协议来传输数据，无连接（连接一次处理完请求和响应之后会断开连接），可以传输任何类型的数据（通过content-Type进行设置），无状态（对于前面的信息，后面需要就要重传，不能复用），端口号为80。

### （2）常见方法

get，post，delete， head.

get和post的区别：

1.get一次请求中包含header和data,请求成功后直接返回200 0k, post先发送header，返回100 continue后，再发送data,然后返回200 ok.

2.get通过url来传输数据，post数据存放在body

3.get数据暴露在外，不安全，post相对安全

4.get只产生一个TCP数据包，post产生两个数据包。

5.get的参数会保留在浏览历史记录中，而post不会。

6.get只能进行url编码，而post支持多种编码方式。

7.get是安全（请求方法不会破坏服务器上的资源）幂等（多次执行相同操作，结果相同）的

### （2）HTTP中包含的主要内容

![image-20220709171445238](C:\Users\hasee\AppData\Roaming\Typora\typora-user-images\image-20220709171445238.png)

### （3）响应状态码

    200 ：请求成功。
    301 ：永久重定向，转移到其它url，永久性的移动
    302 ：请求重定向。
    304 ：请求资源没有改变，访问本地缓存。
    400 ：语义有误，当前请求无法被服务器理解
    401 ：未授权、认证失败
    403 ：请求被服务器拒绝访问
    404 ：请求资源不存在。通常是用户路径编写错误，也可能是服务器资源已删除。
    500 ：服务器内部错误。通常程序抛异常。
    503 ：临时的服务器维护（或部署启动的期间）、过载，当前无法处理请求，在一段时间后会恢复

### （4）转发和重定向的区别

重定向地址栏会发生改变，重定向会请求2次数据，服务状态码为302/301/307，重定向可以访问其他站点，浏览器发起第二次的请求是根据响应头的Location中的url来进行。

转发地址栏不变，只有一次请求，只能服务器内部资源进行转发。

### （5）cookie和session（会话管理）

为什么使用cookie和session就能进行会话管理：

cookie可以在浏览器中存储一些数据，而session是在服务存储数据的，通过这些数据可以用来识别用户。cookie相当于是服务器颁发个用户的身份证，下次访问时带着身份证，服务器就可以识别信息。

为什么使用cookie和session：

因为http是无状态的一种协议，登录后的访问页面如果都携带用户账号和密码不安全，所以通过会话管理来进行之后的访问操作.

存储位置：cookie存储在客户端的浏览器上，而session存放在服务器上。

其中在服务端的session是通过键值对的形式进行保存

使用cookie-session实现过程

在登录时进行校验，校验成功，就生成一个随机字符串（sessionId)和一个session对象（如保存用户信息），将这两个保存在map结构中，返回响应的HTTP数据包中的set-cookie的响应头中共包含sessionid，客户端将set-cookie的内容保存在客户端本地，之后客户端每次请求时都会在请求头的cookie携带sessionId，之后服务端现货区到请求头中的内容，然后查看sessionId和保存的Map中的结果进行对比，如果存在就是登录用户，如果为null就未登录。

如果cookie被禁用时，可以通过url（querystring来保持状态），可以通过表单变量保持状态。

服务端重启后session就会消失，在服务端的session也有默认的过期时间；cookie也有过期时间（过期后就不会再携带）。

### （6）HTTP和HTTPS的区别

1.http的端口号为80,https的端口号为443

2.http是明文传输，https是通过tsl进行加密传输

3.https在三次握手后，还需要使用SSL的handshake来协商加密后的对称密钥

4.https需要服务端申请证书，浏览器端安装对应的证书

5.http建立握手连接时会有3个包，而https会产生3个包+SSL产生的9个包=12个包；所以https的速度比http的慢

### （7）HTTPS流程

1.使用非对称加密生成对称密钥：

两次明文传输两个随机字符串和一次密文传输一个随机字符串，客户端和服务端基于这三个随机字串生成相同的对话密钥。

2.使用对称加密传输数据：客户端使用之前生成的密钥对请求的数据进行加密，之后服务端也使用同样的秘钥来对接收的数据进行解密。



自己总结

通过ssl协议建立连接

1.首先客户端向服务端发送加密通讯请求，其中包含客户端支持的ssl协议版本，客户端产生的随机字符串，和客户端支持的密码套件列表（RSA加密算法）

2.服务端收到请求后，向客户端发送响应，其中包含确认ssl协议版本（如果不支持，就关闭加密通讯），包含服务端产生的随机数，确认的密码套件列表（RSA加密算法），服务器的数字证书

3.客户端收到服务端的响应后，首先确认数字证书的真实性，没问题就会从CA帧数中取出服务器公钥，然后使用公钥加密报文

4.然后再向服务端发送数据，包含一个随机字符串（该字符串被公钥加密），加密通信算法改变通知（表示之后会用会话密钥加密通信）

5.服务端收到第三个随机数后通过协商的加密算法生成会话密钥，然后向客户端发送机密通信算法改变通知（表示之后使用会话密钥加密通信），服务端握手结束通知，之后就使用对称加密来传输数据，客户端和服务端使用同样的会话密钥进行解密

## 4.Ajax相关内容

### （1）Ajax的技术

是一种异步回调技术：Ajax发送一个请求时，不需要继续等待，向下继续执行js的代码，等获取到响应后，浏览器内部会自动的调用回调函数。

### （2）使用Ajax的原因

首先不需要刷新页面就可以发送HTTP请求：用户体验好。

效率高，网络通讯中只是获取动态数据的变化，传输的数据量就变少了（相较于模板引擎，不用获取整个html页面，使用ajax之后通过前端来进行渲染页面），Ajax使用前后端分离，降低了代码的耦合性。



## 5.vue框架的使用

优点：体积小，运行效率高，

主要是对数据的双向绑定。

## 6.WebSocket的使用

web聊天室需要对向服务端发送的新消息再发送给其他在线用户

### （1）业务分析及思路

因为http协议对于客户端来说，可以主动的发送消息，然后服务端返回响应（接收到响应后就会断开连接，采取一发一收的方式），如果需要服务端主动的推送消息给客户端，http协议就做不到。

如果不考虑服务端主动推送消息，就有以下解决方式（相当于是从服务端拉取消息）：

1.轮询的方式：客户端定时的发送消息，来查看服务端是否有新消息，缺点：效率低，浪费带宽（需要处理请求和响应）。

2.长轮询的方式：客户端发送请求，如果没有新消息，就保持住连接，有新消息就返回。缺点：效率低

3.使用websocket的推的方式：全双工，建立一个长连接，服务端可以主动地向客户端发送消息，客户端也可以主动地向服务端发送消息。底层是基于socket编程，建立一个tcp协议的长连接来进行实现的。

### （2）websocket的实现原理

1.通过握手阶段来建立连接（使用HTTP协议），目的是使双方规定好协议和钥匙，方便后序进行通讯

2.之后使用websocket来进行收发数据（应用层使用相同的数据格式来进行收发数据）。

### （3）具体使用的相关方法

前端和后端都需要准备

onOpen（建立连接），onMesssage（接收消息）,onError（抛异常执行）,onClose（关闭连接）	

## 7.项目优化

### （1）存放用户的会话数据时，使用ConcurrentHashMap

使用的原因：对于每个新用户来说，涉及到同一块数据区map的写操作，而Servlet不是线程安全的,采用多线程方式运行其service方法，存在线程安全问题，所以使用ConcurrentHashMap，不使用hashtable是因为它使用synchronized来加锁，锁的是整张表，多个线程竞争时效率低。而ConcurrentHashMap锁的的每个桶，各个桶之间是没有锁的；而且对于读操作是不加锁的

### （2）ConcurrentHashMap的基本原理

底层数据结构：数组+链表+红黑树

锁定头结点的方式缩小了锁的粒度，初始数组或的头结点的时候没有加锁，采用的是CAS进行原子替换（原子操作）。

插入数据时会加锁处理，锁的是桶的头结点。

扩容时也会加锁处理，锁的也是头结点，而且是多个线程同时参与扩容，如果有线程put（），就会参与扩容过程，完成扩容后，再将数据插入到新数组中。

查找数据时不会加锁。再进行扩容的时候也支持查找.

### （3）HashMap扩容为2倍的原因

1.扩容时减少就元素位置的移动

2.可以使元素均匀散布在hashmap中，减少哈希碰撞

### （4）阻塞队列（Block）来管理新消息

刚开始使用的是收到新消息后，遍历session，然后发送给每个用户，在同一线程下处理，效率较低。

优化：创建一个单独的线程（使用静态代码块，在类加载时就启动）来专门从阻塞队列中取消息并发送给所有用户

阻塞队列原理（生产者消费者模型）：队列满时，再添加元素就进行阻塞；当队列为空时，再获取元素时，就进行阻塞。解决了生产者和消费者之间的耦合。

实现方式：基于通知机制，wait和notify/notifyAll来进行实现。

使用的接口为BlockingQueue，类是LinkedBolckingQueue（基于数组的无界阻塞队列，默认大小为int最大值）或ArrayBlockingQueue（基于单向链表的有界阻塞队列，需要指定初始大小，可以指定公平性（通过ReentrantLock保证）：可以按照阻塞的先后顺序访问队列，会降低吞吐量）。使用put（）和take（）能达到阻塞的作用。

## 8.其他优化的方式

（1）将人员分成多个组（线程），有消息后，分别给各个组中的成员来发送消息。

（2）进行上下线的管理，超过多长时间没有响应的话，就将该用户下线（定时器来实现）。

（3）消息过多时只显示部分消息，之后可以设置一个拉取按钮，来获取多余的信息。

## 9.synchronized和ReentrantLock的底层和区别

### （1）synchronized

synchronized是基于JVM进行实现的，加锁和释放锁都是自动完成，每个对象都有一个监视器monitor，通过监视器来判断该对象是否被某个线程所持有。为非公平锁

对synchronized的优化有锁消除和锁粗化

synchronized的四种状态：无锁，偏向锁，轻量级锁，重量级锁

偏向锁：该线程第一次获取锁的时候就标记一下，当该线程再次获取锁的时候检查是否标记，如果标记就不需要申请锁。

轻量级锁：由偏向锁升级而来，以cas加自旋的方式

### （2）ReentrantLock

是一个类，主要通过CAS和AQS来实现需要手动加锁和释放锁，可以设置等待时间，避免死锁。可以设置公平锁，默认为非公平锁

## 10.AQS

### （1）什么是AQS

抽象队列同步器，主要用来实现线程同步,AQS通过一个同步队列来维护获取锁失败，进入阻塞状态的线程，且这个同步队列是一个双向链表。

AQS的两种功能：独占和共享

### （2）AQS实现线程同步的过程

首先通过一个state来记录当前的同步状态，之后如果当前锁已经获取，其他线程进入阻塞状态，加入到同步队列的队尾，如果锁被释放，唤醒队头的下一个线程尝试获取锁，获取成功将原队头删除，设置当前结点为新队头。在向队尾添加结点的时候，如果第一次添加失败，之后会以CAS的方式持续进行。











